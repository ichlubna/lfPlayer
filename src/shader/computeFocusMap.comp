#version 450
#include "computeHeader.glsl"

//discards the 4th attribute
float colorDistance(vec4 a, vec4 b)
{
    //return max(max(max(abs(a.r-b.r), abs(a.g-b.g)), abs(a.b-b.b)), abs(a.a-b.a)); //Chebyshev
    return max(max(abs(a.r-b.r), abs(a.g-b.g)), abs(a.b-b.b)); //Chebyshev
}

float blockDistance(mat4 a, mat4 b)
{
    float totalDistance = 0; 
    for(int i=0; i<4; i++)
        totalDistance += colorDistance(a[i], b[i]);
    vec4 x=vec4(a[0][3], a[1][3], a[2][3], 1.0f);
    vec4 y=vec4(b[0][3], b[1][3], b[2][3], 1.0f);
    totalDistance += colorDistance(x,y);
    return totalDistance;
}

mat4 sampleImage(vec2 coord, int textID)
{
    vec4 c = texture(sampler2D(textures[textID+2], textSampler), coord);
    mat4 block;
    for(int i=0; i<4; i++)
        block[i] = texture(sampler2D(textures[textID+2], textSampler), coord+(vec2(1.0f,1.01f)-2*vec2(i/2, i%2))*LF_HALF_PX_SIZE*3);
    block[0][3] = c.r;
    block[1][3] = c.g;
    block[2][3] = c.b;
    return block;
}

struct Welford
{
    mat4 mean;
    float m2;
    int n;
};
Welford welford = Welford(mat4(0),0,0);
void addWelford(mat4 block)
{
    welford.n++;
    mat4 delta = block-welford.mean;
    float dist = blockDistance(block, welford.mean);
    welford.mean += delta/welford.n;
    welford.m2 = dist*blockDistance(block, welford.mean);
}
float finishWelford()
{
    float result = welford.m2;// /4*welford.n
    welford.mean = mat4(0);
    welford.m2 = 0;
    welford.n = 0;
    return result; 
}

float getVariance(int s)
{
    for(int i=0; i<4; i++)
    {
        vec2 offset = vec2(lfFrameOffset(i)*calculateFocus(s)*rangeLimit);
        offset.x *= ASPECT_RATIO;
        vec2 coord = mapUV + offset;
        addWelford(sampleImage(coord, i));
    }
    return finishWelford();
}

void main()
{
    if(any(greaterThan(outCoord,ivec2(MAP_WIDTH,MAP_HEIGHT))))
        return;
/* 
    float minVariance = 999.0f;
    int minSample = 0;
    for(int i=0; i<SAMPLE_COUNT; i++)
    { 
        float variance = getVariance(i);
        if(variance < minVariance)
        {
            minVariance = variance;
            minSample = i;
        }
    }
*/

    const vec2 INIT_MIN = vec2(9999.0f, 0);
    vec2 mins[3] = {INIT_MIN, INIT_MIN, INIT_MIN};
    for(int i=0; i<SAMPLE_COUNT; i++)
    { 
        float variance = getVariance(i);
        if(variance < mins[0].x)
        {
            mins[2] = mins[1];
            mins[1] = mins[0];
            mins[0] = vec2(variance, float(i));
        }
        else if(variance < mins[1].x)
        {
            mins[2] = mins[1];
            mins[1] = vec2(variance, float(i));
        }
        else if(variance < mins[2].x)
        {
            mins[2] = vec2(variance, float(i));
        }
    } 
    
    vec2 pixel = vec2(mins[0].y/SAMPLE_COUNT, 0);
    vec2 delta = abs(mins[0]-mins[1]) + abs(mins[2]-mins[1]) + abs(mins[0]-mins[2]);
    delta /= 3;
    if(mins[1].x > 0.0005)
    if(delta.y > 0.1*SAMPLE_COUNT)
        pixel.y = 1.0f;

    imageStore(images[FOCUSMAP_TEXTURE_ID], outCoord, vec4(pixel,0,0));
}
