#version 450
#include "computeHeader.glsl"
vec2 PX_SIZE = 1.0f/ivec2(WIDTH, HEIGHT);
vec2 HALF_PX_SIZE = PX_SIZE/2;

float colorToGrayscale(vec4 c)
{
    return c.r*0.299 + c.g*0.587 + c.b*0.114;
}

//discards the 4th attribute
float colorDistance(vec4 a, vec4 b)
{
    return max(max(abs(a.r-b.r), abs(a.g-b.g)), abs(a.b-b.b)); //Chebyshev
    //return max(max(abs(a.r-b.r), abs(a.g-b.g)), abs(a.b-b.b)); //Chebyshev
}

vec4 blockDistance(mat4 a, mat4 b)
{
    vec4 distances = vec4(0);
    for(int i=0; i<4; i++)
        distances[i] = colorDistance(a[i], b[i]);
    return distances;
}

mat4 sampleImage(ivec2 coord, int textID)
{
    const vec2 uv = normalizeCoord(coord);
    vec4 c = texture(sampler2D(textures[textID+2], textSampler), uv);
    mat4 block;
    for(int i=0; i<4; i++)
        block[i] = texture(sampler2D(textures[textID+2], textSampler), uv+(vec2(1.0f,1.01f)-2*vec2(i/2, i%2))*HALF_PX_SIZE*3);
    return block;
}

struct Welford
{
    mat4 mean;
    vec4 m2;
    int n;
};
    Welford welford = Welford(mat4(0),vec4(0),0);
void addWelford(mat4 block)
{
    welford.n++;
    mat4 delta = block-welford.mean;
    vec4 dist = blockDistance(block, welford.mean);
    welford.mean += delta/welford.n;
    welford.m2 = dist*blockDistance(block, welford.mean);
}
float finishWelford()
{
    float result = dot(welford.m2, vec4(1)); // /4*welford.n
    welford.mean = mat4(0);
    welford.m2 = vec4(0);
    welford.n = 0;
    return result; 
}

void main()
{
    const ivec2 outCoord = ivec2(gl_GlobalInvocationID.xy);
    if(any(greaterThan(outCoord,ivec2(WIDTH,HEIGHT))))
        return;
    
    float minVariance = 999.0f;
    int minSample = 0;
    for(int i=0; i<SAMPLE_COUNT; i++)
    { 
        for(int j=0; j<4; j++)
        {
            ivec2 coord = outCoord + ivec2(round(lfFrameOffset(j)*getPxFocus(i)));
            addWelford(sampleImage(coord, j));
        }
        float variance = finishWelford();
        if(variance < minVariance)
        {
            minVariance = variance;
            minSample = i;
        }
     }
     imageStore(images[FOCUSMAP_TEXTURE_ID], outCoord, vec4(float(minSample)/SAMPLE_COUNT));
}
